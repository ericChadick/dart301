[gd_scene format=3 uid="uid://hyeh47v46j86"]

[ext_resource type="PackedScene" uid="uid://dckfnquaidfil" path="res://UI/player_ui.tscn" id="1_tsyqh"]
[ext_resource type="PackedScene" uid="uid://cqrenk8ue8j8v" path="res://Player/player.tscn" id="2_8fnaj"]
[ext_resource type="PackedScene" uid="uid://bxgwgbkpugt5j" path="res://World/Outlet/outlet.tscn" id="3_ffrie"]
[ext_resource type="Script" uid="uid://bl44lp1yridj8" path="res://Enemies/enemy.gd" id="4_55wc7"]
[ext_resource type="PackedScene" uid="uid://balgpgdnfqd4g" path="res://Enemies/Enemie1/Drone.fbx" id="4_bghym"]

[sub_resource type="Environment" id="Environment_br3nj"]
background_mode = 1
background_color = Color(0.6006, 0.66, 0.66, 1)
glow_enabled = true
fog_light_color = Color(0, 0, 0, 1)
volumetric_fog_enabled = true
volumetric_fog_albedo = Color(0.24299997, 0.40514997, 0.45, 1)
volumetric_fog_length = 86.0

[sub_resource type="GDScript" id="GDScript_ffrie"]
script/source = "## Controls the flow of execution of the entire behavior tree.
@tool
@icon(\"../icons/tree.svg\")
class_name BeehaveTree extends Node

enum { SUCCESS, FAILURE, RUNNING }

enum ProcessThread { IDLE, PHYSICS, MANUAL }

signal tree_enabled
signal tree_disabled

## Whether this behavior tree should be enabled or not.
@export var enabled: bool = true:
	set(value):
		enabled = value
		set_physics_process(enabled and process_thread == ProcessThread.PHYSICS)
		set_process(enabled and process_thread == ProcessThread.IDLE)
		if value:
			tree_enabled.emit()
		else:
			interrupt()
			tree_disabled.emit()

	get:
		return enabled

## How often the tree should tick, in frames. The default value of 1 means
## tick() runs every frame.
@export var tick_rate: int = 1

## An optional node path this behavior tree should apply to.
@export_node_path var actor_node_path: NodePath:
	set(anp):
		actor_node_path = anp
		if actor_node_path != null and str(actor_node_path) != \"..\":
			actor = get_node(actor_node_path.get_as_property_path())
		else:
			actor = get_parent()
		if Engine.is_editor_hint():
			update_configuration_warnings()

## Whether to run this tree in a physics or idle thread.
@export var process_thread: ProcessThread = ProcessThread.PHYSICS:
	set(value):
		process_thread = value
		self.enabled = self.enabled and process_thread != ProcessThread.MANUAL
		set_physics_process(enabled and process_thread == ProcessThread.PHYSICS)
		set_process(enabled and process_thread == ProcessThread.IDLE)

## Custom blackboard node. An internal blackboard will be used
## if no blackboard is provided explicitly.
@export var blackboard: Blackboard:
	set(b):
		blackboard = b
		if blackboard and _internal_blackboard:
			remove_child(_internal_blackboard)
			_internal_blackboard.free()
			_internal_blackboard = null
		elif not blackboard and not _internal_blackboard:
			_internal_blackboard = Blackboard.new()
			add_child(_internal_blackboard, false, Node.INTERNAL_MODE_BACK)
	get:
		# in case blackboard is accessed before this node is,
		# we need to ensure that the internal blackboard is used.
		if not blackboard and not _internal_blackboard:
			_internal_blackboard = Blackboard.new()
			add_child(_internal_blackboard, false, Node.INTERNAL_MODE_BACK)
		return blackboard if blackboard else _internal_blackboard

## When enabled, this tree is tracked individually
## as a custom monitor.
@export var custom_monitor = false:
	set(b):
		custom_monitor = b
		if custom_monitor and _process_time_metric_name != \"\":
			Performance.add_custom_monitor(
				_process_time_metric_name, _get_process_time_metric_value
			)
			_get_global_metrics().register_tree(self)
		else:
			if _process_time_metric_name != \"\":
				# Remove tree metric from the engine
				Performance.remove_custom_monitor(_process_time_metric_name)
				_get_global_metrics().unregister_tree(self)

			BeehaveDebuggerMessages.unregister_tree(get_instance_id())

@export var actor: Node:
	set(a):
		actor = a
		if actor == null:
			actor = get_parent()
		if Engine.is_editor_hint():
			update_configuration_warnings()

var status: int = -1
var last_tick: int = -1

var _internal_blackboard: Blackboard
var _process_time_metric_name: String
var _process_time_metric_value: float = 0.0
var _can_send_message: bool = false


func _ready() -> void:
	var connect_scene_tree_signal = func(signal_name: String, is_added: bool):
		if not get_tree().is_connected(signal_name, _on_scene_tree_node_added_removed.bind(is_added)):
			get_tree().connect(signal_name, _on_scene_tree_node_added_removed.bind(is_added))
	connect_scene_tree_signal.call(\"node_added\", true)
	connect_scene_tree_signal.call(\"node_removed\", false)

	if not process_thread:
		process_thread = ProcessThread.PHYSICS

	if not actor:
		if actor_node_path:
			actor = get_node(actor_node_path)
		else:
			actor = get_parent()

	if not blackboard:
		# invoke setter to auto-initialise the blackboard.
		self.blackboard = null

	# Get the name of the parent node name for metric
	_process_time_metric_name = (
		\"beehave [microseconds]/process_time_%s-%s\" % [actor.name, get_instance_id()]
	)

	set_physics_process(enabled and process_thread == ProcessThread.PHYSICS)
	set_process(enabled and process_thread == ProcessThread.IDLE)

	# Register custom metric to the engine
	if custom_monitor and not Engine.is_editor_hint():
		Performance.add_custom_monitor(_process_time_metric_name, _get_process_time_metric_value)
		_get_global_metrics().register_tree(self)

	if Engine.is_editor_hint():
		update_configuration_warnings.call_deferred()
	else:
		# Ensure the local debugger knows about the tree *before* telling the editor.
		_get_global_debugger().register_tree(self)
		BeehaveDebuggerMessages.register_tree(_get_debugger_data(self))


func _on_scene_tree_node_added_removed(node: Node, is_added: bool) -> void:
	if Engine.is_editor_hint():
		return

	if node is BeehaveNode and is_ancestor_of(node):
		var sgnal := node.ready if is_added else node.tree_exited
		if is_added:
			sgnal.connect(
				func() -> void: BeehaveDebuggerMessages.register_tree(_get_debugger_data(self)),
				CONNECT_ONE_SHOT
			)
		else:
			sgnal.connect(
				func() -> void:
					BeehaveDebuggerMessages.unregister_tree(get_instance_id())
					request_ready()
			)


func _physics_process(_delta: float) -> void:
	tick()


func _process(_delta: float) -> void:
	tick()


func tick() -> int:
	if Engine.is_editor_hint():
		return -1
	if last_tick != -1 and last_tick < tick_rate - 1:
		last_tick += 1
		return -1

	last_tick = 0

	# Start timing for metric
	var start_time = Time.get_ticks_usec()
	blackboard.set_value(\"can_send_message\", _can_send_message)

	if _can_send_message and not Engine.is_editor_hint():
		BeehaveDebuggerMessages.process_begin(get_instance_id(), blackboard.get_debug_data())

	if actor == null or get_child_count() == 0:
		return FAILURE
	var child := self.get_child(0)
	if status != RUNNING:
		child.before_run(actor, blackboard)

	status = child.tick(actor, blackboard)
	if _can_send_message:
		BeehaveDebuggerMessages.process_tick(child.get_instance_id(), status, blackboard.get_debug_data())
		BeehaveDebuggerMessages.process_tick(get_instance_id(), status, blackboard.get_debug_data())

	# Clear running action if nothing is running
	if status != RUNNING:
		blackboard.set_value(\"running_action\", null, str(actor.get_instance_id()))
		child.after_run(actor, blackboard)
		
	if _can_send_message and not Engine.is_editor_hint():
		BeehaveDebuggerMessages.process_end(get_instance_id(), blackboard.get_debug_data())

	# Check the cost for this frame and save it for metric report
	_process_time_metric_value = Time.get_ticks_usec() - start_time
	
	return status


func _get_configuration_warnings() -> PackedStringArray:
	var warnings: PackedStringArray = []

	if actor == null:
		warnings.append(\"Configure target node on tree\")

	if get_children().any(func(x): return not (x is BeehaveNode)):
		warnings.append(\"All children of this node should inherit from BeehaveNode class.\")

	if get_child_count() != 1:
		warnings.append(\"BeehaveTree should have exactly one child node.\")

	return warnings


## Returns the currently running action
func get_running_action() -> ActionLeaf:
	return blackboard.get_value(\"running_action\", null, str(actor.get_instance_id()))


## Returns the last condition that was executed
func get_last_condition() -> ConditionLeaf:
	return blackboard.get_value(\"last_condition\", null, str(actor.get_instance_id()))


## Returns the status of the last executed condition
func get_last_condition_status() -> String:
	if blackboard.has_value(\"last_condition_status\", str(actor.get_instance_id())):
		var status = blackboard.get_value(
			\"last_condition_status\", null, str(actor.get_instance_id())
		)
		if status == SUCCESS:
			return \"SUCCESS\"
		elif status == FAILURE:
			return \"FAILURE\"
		else:
			return \"RUNNING\"
	return \"\"


## interrupts this tree if anything was running
func interrupt() -> void:
	if self.get_child_count() != 0:
		var first_child = self.get_child(0)
		if \"interrupt\" in first_child:
			first_child.interrupt(actor, blackboard)


## Enables this tree.
func enable() -> void:
	self.enabled = true


## Disables this tree.
func disable() -> void:
	self.enabled = false


func _exit_tree() -> void:
	if Engine.is_editor_hint():
		# Skip this when running in editor
		return
	if custom_monitor:
		if _process_time_metric_name != \"\":
			# Remove tree metric from the engine
			Performance.remove_custom_monitor(_process_time_metric_name)
		_get_global_metrics().unregister_tree(self)
		BeehaveDebuggerMessages.unregister_tree(get_instance_id())


# Called by the engine to profile this tree
func _get_process_time_metric_value() -> int:
	return int(_process_time_metric_value)


func _get_debugger_data(node: Node) -> Dictionary:
	if not (node is BeehaveTree or node is BeehaveNode):
		return {}

	var data := {
		path = node.get_path(),
		name = node.name,
		type = node.get_class_name(),
		id = str(node.get_instance_id())
	}
	if node.get_child_count() > 0:
		data.children = []
	for child in node.get_children():
		var child_data := _get_debugger_data(child)
		if not child_data.is_empty():
			data.children.push_back(child_data)
	return data


func get_class_name() -> Array[StringName]:
	return [&\"BeehaveTree\"]


# required to avoid lifecycle issues on initial load
# due to loading order problems with autoloads
func _get_global_metrics() -> Node:
	return get_tree().root.get_node(\"BeehaveGlobalMetrics\")


# required to avoid lifecycle issues on initial load
# due to loading order problems with autoloads
func _get_global_debugger() -> Node:
	return get_tree().root.get_node(\"BeehaveGlobalDebugger\")
"

[sub_resource type="GDScript" id="GDScript_br3nj"]
script/source = "## A Selector runs its children in order until one succeeds or is running.
## On failure, skips already-processed children across ticks.
@tool
@icon(\"../../icons/selector.svg\")
class_name SelectorComposite extends Composite


var last_execution_index: int = 0
var previous_success_or_running_index: int = -1
var ready_to_interrupt_all: bool = false


func tick(actor: Node, blackboard: Blackboard) -> int:
	var children = get_children()
	var children_count = children.size()
	var processed_count = 0
	
	for i in range(children.size()):
		var child = children[i]
		if child.get_index() < last_execution_index:
			processed_count += 1
			continue

		if child != running_child:
			child.before_run(actor, blackboard)

		var response = child._safe_tick(actor, blackboard)
		processed_count += 1
		
		if can_send_message(blackboard):
			BeehaveDebuggerMessages.process_tick(child.get_instance_id(), response, blackboard.get_debug_data())

		if child is ConditionLeaf:
			var id = str(actor.get_instance_id())
			blackboard.set_value(\"last_condition\", child, id)
			blackboard.set_value(\"last_condition_status\", response, id)

		match response:
			SUCCESS:
				if running_child != null:
					if running_child != child:
						running_child.interrupt(actor, blackboard)
					_cleanup_running(running_child, actor, blackboard)
				child.after_run(actor, blackboard)
				_interrupt_children(actor, blackboard, i, previous_success_or_running_index)
				previous_success_or_running_index = i
				ready_to_interrupt_all = false
				return SUCCESS

			FAILURE:
				if running_child != null and running_child == child:
					_cleanup_running(running_child, actor, blackboard)
				child.after_run(actor, blackboard)
				last_execution_index = max(last_execution_index, child.get_index() + 1)

			RUNNING:
				if child != running_child:
					if running_child != null:
						running_child.interrupt(actor, blackboard)
					running_child = child
				if child is ActionLeaf:
					blackboard.set_value(\"running_action\", child, str(actor.get_instance_id()))
				_interrupt_children(actor, blackboard, i, previous_success_or_running_index)
				previous_success_or_running_index = i
				ready_to_interrupt_all = false
				return RUNNING

	# all children failed
	ready_to_interrupt_all = (processed_count == children_count)
	last_execution_index = 0
	return FAILURE


func after_run(actor: Node, blackboard: Blackboard) -> void:
	last_execution_index = 0
	super(actor, blackboard)


func interrupt(actor: Node, blackboard: Blackboard) -> void:
	if ready_to_interrupt_all:
		# If all children failed, interrupt all children by using indices 0 and children.size()-1
		var children = get_children()
		if children.size() > 0:
			_interrupt_children(actor, blackboard, -1, children.size() - 1)
		ready_to_interrupt_all = false
	else:
		# Use the normal interrupt logic for partial processing
		_interrupt_children(actor, blackboard, last_execution_index, previous_success_or_running_index)
	if running_child != null:
		running_child.interrupt(actor, blackboard)
		_cleanup_running(running_child, actor, blackboard)
	last_execution_index = 0
	previous_success_or_running_index = -1
	super(actor, blackboard)


func get_class_name() -> Array[StringName]:
	var classes = super()
	classes.push_back(&\"SelectorComposite\")
	return classes
"

[sub_resource type="GDScript" id="GDScript_xn6gn"]
script/source = "@tool
extends ConditionLeaf

@export_range(0, 100, 1, \"suffix:%\") var health_percentage: int = 0

func tick(actor: Node, _blackboard: Blackboard) -> int:
	if not actor:
		return FAILURE
	var actor_health_percent: float = float(actor.health)/float(actor.max_health)
	if actor_health_percent < health_percentage:
		return SUCCESS
	else:
		return FAILURE
"

[sub_resource type="GDScript" id="GDScript_bghym"]
script/source = "@tool
class_name CalculateMoveDirection_BH
extends ActionLeaf

enum MoveType {
	TO_TARGET = 0,
	AWAY_FROM_TARGET = 1,
}

@export var move_type: MoveType = MoveType.TO_TARGET

func tick(actor: Node, _blackboard: Blackboard) -> int:
	var enemy_actor := actor as Node3D
	if enemy_actor == null:
		return FAILURE

	var target := get_tree().get_first_node_in_group(\"player\") as Node3D
	if target == null:
		return FAILURE

	match move_type:
		MoveType.AWAY_FROM_TARGET:
			# direction from target -> enemy (so enemy moves away)
			enemy_actor.move_direction = target.global_position.direction_to(enemy_actor.global_position)
			return SUCCESS

		MoveType.TO_TARGET:
			# direction from enemy -> target
			enemy_actor.move_direction = enemy_actor.global_position.direction_to(target.global_position)
			return SUCCESS

	return FAILURE
"

[node name="TestEnemy_tscn" type="Node3D" unique_id=1924405938]

[node name="PlayerUI" parent="." unique_id=883918654 instance=ExtResource("1_tsyqh")]

[node name="SubViewportContainer" type="SubViewportContainer" parent="PlayerUI" unique_id=1488802912]
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
mouse_filter = 2
stretch = true
stretch_shrink = 4

[node name="SubViewport" type="SubViewport" parent="PlayerUI/SubViewportContainer" unique_id=1046679752]
handle_input_locally = false
audio_listener_enable_3d = true
size = Vector2i(320, 215)
size_2d_override_stretch = true
render_target_update_mode = 4

[node name="CSGBox3D" type="CSGBox3D" parent="PlayerUI/SubViewportContainer/SubViewport" unique_id=825956912]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, -9.136589, -3.163, -98.35701)
use_collision = true
size = Vector3(38.63057, 5.0889893, 219.60583)

[node name="CSGBox3D8" type="CSGBox3D" parent="PlayerUI/SubViewportContainer/SubViewport" unique_id=2040221876]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 78.558334, 18.124975, -98.35701)
use_collision = true
size = Vector3(38.63057, 5.0889893, 219.60583)

[node name="CSGBox3D6" type="CSGBox3D" parent="PlayerUI/SubViewportContainer/SubViewport" unique_id=1858358373]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 14.424938, 10.274113, -98.35701)
use_collision = true
size = Vector3(13.911476, 32, 219.60583)

[node name="CSGBox3D7" type="CSGBox3D" parent="PlayerUI/SubViewportContainer/SubViewport" unique_id=1807742946]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, -31.490223, 10.566074, -98.35701)
use_collision = true
size = Vector3(13.911476, 32.583923, 219.60583)

[node name="CSGBox3D2" type="CSGBox3D" parent="PlayerUI/SubViewportContainer/SubViewport" unique_id=48048741]
transform = Transform3D(0.29964027, 0, -0.9540523, 0, 1, 0, 0.9540523, 0, 0.29964027, 3.671226, 2.4992502, -48.092133)
use_collision = true
size = Vector3(8.831219, 7.5484314, 17.591831)

[node name="CSGBox3D5" type="CSGBox3D" parent="PlayerUI/SubViewportContainer/SubViewport" unique_id=1753900644]
transform = Transform3D(0.85919213, 0, -0.51165307, 0, 1, 0, 0.51165307, 0, 0.85919213, -26.949791, 1.5899942, -35.579586)
use_collision = true
size = Vector3(20.473919, 5.7299194, 6.6466236)

[node name="Player" parent="PlayerUI/SubViewportContainer/SubViewport" unique_id=1517765959 instance=ExtResource("2_8fnaj")]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, -7.9193344, 1.5280628, -2.4022925)

[node name="WorldEnvironment" type="WorldEnvironment" parent="PlayerUI/SubViewportContainer/SubViewport" unique_id=1547834592]
environment = SubResource("Environment_br3nj")

[node name="DirectionalLight3D" type="DirectionalLight3D" parent="PlayerUI/SubViewportContainer/SubViewport" unique_id=1518879193]
transform = Transform3D(0.9153607, 0.12700464, 0.3820794, -0.40263486, 0.2887357, 0.86862934, 0, -0.9489476, 0.31543377, 0, 7.3581166, 0)
shadow_enabled = true

[node name="CSGBox3D3" type="CSGBox3D" parent="PlayerUI/SubViewportContainer/SubViewport" unique_id=1324758803]
transform = Transform3D(0.018534422, 0, 0.9998282, 0, 1, 0, -0.9998282, 0, 0.018534422, -13.847928, 1.3077011, -85.65367)
use_collision = true
size = Vector3(8.309418, 6.057556, 11.516392)

[node name="Outlet" parent="PlayerUI/SubViewportContainer/SubViewport" unique_id=220038749 instance=ExtResource("3_ffrie")]
transform = Transform3D(0.7857922, 0, 0.61849064, 0, 1, 0, -0.61849064, 0, 0.7857922, -4.8091483, 4.0179935, -45.29271)

[node name="CSGBox3D4" type="CSGBox3D" parent="PlayerUI/SubViewportContainer/SubViewport" unique_id=1083920867]
transform = Transform3D(0.3969877, 0, -0.9178239, 0, 1, 0, 0.9178239, 0, 0.3969877, -15.816255, 0.67638874, -15.914407)
use_collision = true
size = Vector3(1.5280151, 2.7254639, 2.0904007)

[node name="Outlet2" parent="PlayerUI/SubViewportContainer/SubViewport" unique_id=1931095423 instance=ExtResource("3_ffrie")]
transform = Transform3D(0.3969877, 0, -0.9178239, 0, 1, 0, 0.9178239, 0, 0.3969877, -15.544044, 0.8243972, -15.222859)

[node name="Outlet3" parent="PlayerUI/SubViewportContainer/SubViewport" unique_id=864816755 instance=ExtResource("3_ffrie")]
transform = Transform3D(-0.64685625, 0, -0.76261187, 0, 1, 0, 0.76261187, 0, -0.64685625, -7.947236, 1.1420511, -85.423836)

[node name="Enemy" type="Node" parent="." unique_id=433773733]
script = ExtResource("4_55wc7")

[node name="Visual" type="Node" parent="Enemy" unique_id=907123010]

[node name="Drone" parent="Enemy/Visual" unique_id=1041426428 instance=ExtResource("4_bghym")]
transform = Transform3D(-0.037603013, 0, -0.9992927, 0, 1, 0, 0.9992927, 0, -0.037603013, -8.201086, 3.3661146, -17.39819)

[node name="BeehaveTree" type="Node" parent="Enemy" unique_id=2021997188 node_paths=PackedStringArray("actor")]
script = SubResource("GDScript_ffrie")
actor_node_path = NodePath("../Visual/Drone")
actor = NodePath(".")

[node name="SelectorComposite" type="Node" parent="Enemy/BeehaveTree" unique_id=1974725233]
script = SubResource("GDScript_br3nj")

[node name="HealthLess30Percent" type="Node" parent="Enemy/BeehaveTree/SelectorComposite" unique_id=704449503]
script = SubResource("GDScript_xn6gn")
health_percentage = 30

[node name="RetreatFromPlayer" type="Node" parent="Enemy/BeehaveTree/SelectorComposite" unique_id=1263759097]
script = SubResource("GDScript_bghym")
